import numpy as np
# Note: Students might need to install matplotlib if they don't have it
# pip install matplotlib
import matplotlib.pyplot as plt

def load_and_combine_bands(red_file, green_file, blue_file):
    """
    Loads the raw R, G, and B band data from CSV files, ensures they are of
    the same dimensions, and combines them into a single RGB image.
    """
    # YOUR CODE HERE
    # Hint: Use np.loadtxt to load the CSV files and np.stack to combine them.
    
    #Try to load the files
    try:
        redArray = np.loadtxt(red_file, delimiter=",", dtype=int, skiprows=1)
        greenArray = np.loadtxt(green_file, delimiter=",", dtype=int, skiprows=1)
        blueArray = np.loadtxt(blue_file, delimiter=",", dtype=int, skiprows=1)
        """
        delimiter = "," - CSV files with real commas!
        dtype=int - Data type for import is integers, values from 0-255
        skiprows = 1 - Tell loadtxt to skip the first header row (which starts
        with a comma for some reason)
        """
    
    #Throw an error if the files aren't found, could be more robust
    except FileNotFoundError:
        print("Error: File(s) not found")
    
    #Check dimensions & make sure all pixel values are valid
    if (redArray.size == greenArray.size == blueArray.size) & (
            validateRgbArrays(redArray, greenArray, blueArray)):
        
        #Stack the pixel array and return it
        pixelArray = np.stack((redArray, greenArray, blueArray), axis=-1)
        return pixelArray
        
    else:
        #If values done line up, return nothing to break the main function
        return None

#Function created by ChatGPT for error checking pixel values
def validateRgbArrays(redArray, greenArray, blueArray):
    channelMap = {
        "Red": redArray,
        "Green": greenArray,
        "Blue": blueArray
    }

    for channelName, array in channelMap.items():
        # Flatten for simple indexing
        flatArray = array.flatten()
        for index, value in enumerate(flatArray):
            if value < 0 or value > 255:
                raise PixelValueOutOfRangeError(channelName, value, index)

    return True

#Custom error class generated by ChatGPT for error handling of pixel values
class PixelValueOutOfRangeError(Exception):
    def __init__(self, channelName, value, index):
        message = f"Pixel value out of range in {channelName}: value={value} at index={index}"
        super().__init__(message)


def convert_radiance_to_reflectance(rgb_image, k=0.8, b=0.1):
    """
    Converts radiance values to reflectance.
    """
    
    """
    The following code was generated by ChatGPT based on the instructions
    for converting radiance to reflectance. 
    
    Converts radiance values (0–255 ints) to reflectance:
        reflectance = k * radiance + b
    Then rescales reflectance to [0, 1].

    Returns:
        reflectanceImage : float32 NumPy array in [0, 1]
    """
    # Convert to float for math
    floatArray = rgb_image.astype(np.float32)

    # Apply the linear conversion
    reflectance = (k * floatArray) + b

    # Normalize to [0, 1]
    reflectanceMin = reflectance.min()
    reflectanceMax = reflectance.max()

    if reflectanceMax > reflectanceMin:
        reflectance = (reflectance - reflectanceMin) / (reflectanceMax - reflectanceMin)
    else:
        reflectance[:] = 0.0  # constant image edge case

    return reflectance

def rescale_to_8bit(reflectance_image):
    """
    Converts the floating point reflectance values to 8-bit integers (0-255).
    """
    
    """
    The following code was generated by ChatGPT based on the instructions to
    convert the refleatance values between 0 and 1 to 8-bit digital numbers.
    
    Converts reflectance values in [0, 1] to 8-bit Digital Numbers (0–255).

    Returns:
        dnImage : uint8 NumPy array
    """
    scaled = reflectance_image * 255.0
    dnImage = np.round(scaled).astype(np.uint8)
    return dnImage
    
    return None

def save_image(image, filename):
    """
    Saves the image to a file.
    """
    # YOUR CODE HERE
    plt.imsave(filename, image)
    pass

def main():
    """
    Main function to process the remote sensing data.
    """
    # File paths for the CSV data
    red_file = 'red.csv'
    green_file = 'green.csv'
    blue_file = 'blue.csv'

    # Task 1: Load and combine bands
    radiance_image = load_and_combine_bands(red_file, green_file, blue_file)
    if radiance_image is not None:
        print("Successfully loaded and combined image bands.")
        # Optional: visualize the raw radiance image
        #plt.imshow(radiance_image)
        #plt.title("Radiance Image")
        #plt.show()

    # "Check Plus" Tasks
    # Task 2: Convert to reflectance
    reflectance_image = convert_radiance_to_reflectance(radiance_image)
    if reflectance_image is not None:
        print("Successfully converted to reflectance.")

    # Task 3: Rescale to 8-bit
    final_image = rescale_to_8bit(reflectance_image)
    if final_image is not None:
        print("Successfully rescaled to 8-bit.")

    # Task 4: Visualize and save the final image
    
    if final_image is not None:
        plt.imshow(final_image)
        plt.title("Final Processed Image")
        plt.show()
        save_image(final_image, 'final_image.png')
        print("Saved final image to final_image.png")
    

if __name__ 
